using System;
using System.Collections.Generic;
using System.Linq;
using Brutal.Numerics;
using KSA;
using caTTY.SkunkworksGameMod.Camera.Animation;

namespace caTTY.SkunkworksGameMod.Camera.Actions;

/// <summary>
/// Builds complete camera animations with optional start and end lerps.
/// This is the central place where lerp logic is applied to action keyframes.
/// </summary>
public static class CameraAnimationBuilder
{
    /// <summary>
    /// Builds a complete animation from action keyframes, optionally adding start and end lerps.
    /// </summary>
    /// <param name="actionKeyframes">Keyframes generated by the camera action.</param>
    /// <param name="context">Context containing lerp parameters and original state.</param>
    /// <returns>Complete list of keyframes including start/end lerps.</returns>
    public static IEnumerable<CameraKeyframe> BuildAnimation(
        IEnumerable<CameraKeyframe> actionKeyframes,
        CameraActionContext context)
    {
        var keyframes = new List<CameraKeyframe>();
        var actionKeyframesList = actionKeyframes.ToList();

        if (actionKeyframesList.Count == 0)
        {
            return keyframes;
        }

        float timeOffset = 0f;

        // Add start lerp if requested
        if (context.UseStartLerp && context.StartLerpTime > 0)
        {
            var startLerpKeyframes = GenerateStartLerp(context, actionKeyframesList[0]);
            keyframes.AddRange(startLerpKeyframes);
            timeOffset += context.StartLerpTime;
        }

        // Add action keyframes with time offset
        foreach (var kf in actionKeyframesList)
        {
            keyframes.Add(new CameraKeyframe(
                kf.Timestamp + timeOffset,
                kf.Offset,
                kf.Yaw,
                kf.Pitch,
                kf.Roll,
                kf.Fov,
                kf.DebugLabel
            ));
        }

        // Add end lerp if requested
        if (context.UseEndLerp && context.EndLerpTime > 0 && context.OriginalState != null)
        {
            var lastActionKeyframe = actionKeyframesList[^1];
            var endLerpStartTime = lastActionKeyframe.Timestamp + timeOffset;
            var endLerpKeyframes = GenerateEndLerp(context, lastActionKeyframe, endLerpStartTime);
            keyframes.AddRange(endLerpKeyframes);
        }

        return keyframes;
    }

    /// <summary>
    /// Generates start lerp keyframes from current position to animation start position.
    /// </summary>
    private static List<CameraKeyframe> GenerateStartLerp(
        CameraActionContext context,
        CameraKeyframe firstActionKeyframe)
    {
        var keyframes = new List<CameraKeyframe>();
        const int keyframeCount = 12; // Number of lerp keyframes

        // Start state: current camera state
        var startOffset = context.CurrentOffset;
        var (startYaw, startPitch, startRoll) = QuaternionToYPR(context.CurrentRotation);
        var startFov = context.CurrentFov;

        // End state: first action keyframe
        var endOffset = firstActionKeyframe.Offset;
        var endYaw = firstActionKeyframe.Yaw;
        var endPitch = firstActionKeyframe.Pitch;
        var endRoll = firstActionKeyframe.Roll;
        var endFov = firstActionKeyframe.Fov;

        for (int i = 0; i < keyframeCount; i++)
        {
            float linearProgress = (float)i / (keyframeCount - 1);
            float easedProgress = EasingFunctions.ApplyEasing(linearProgress, context.StartLerpEasing);

            var offset = Lerp(startOffset, endOffset, easedProgress);
            var yaw = Lerp(startYaw, endYaw, easedProgress);
            var pitch = Lerp(startPitch, endPitch, easedProgress);
            var roll = Lerp(startRoll, endRoll, easedProgress);
            var fov = Lerp(startFov, endFov, easedProgress);

            float timestamp = linearProgress * context.StartLerpTime;
            string? debugLabel = i == 0 ? "Start Lerp Begin" :
                                 i == keyframeCount - 1 ? "Start Lerp End / Action Start" : null;

            keyframes.Add(new CameraKeyframe(timestamp, offset, yaw, pitch, roll, fov, debugLabel));
        }

        return keyframes;
    }

    /// <summary>
    /// Generates end lerp keyframes from animation end position back to original position.
    /// </summary>
    private static List<CameraKeyframe> GenerateEndLerp(
        CameraActionContext context,
        CameraKeyframe lastActionKeyframe,
        float startTime)
    {
        var keyframes = new List<CameraKeyframe>();

        if (context.OriginalState == null)
        {
            return keyframes;
        }

        const int keyframeCount = 12; // Number of lerp keyframes

        // Start state: last action keyframe
        var startOffset = lastActionKeyframe.Offset;
        var startYaw = lastActionKeyframe.Yaw;
        var startPitch = lastActionKeyframe.Pitch;
        var startRoll = lastActionKeyframe.Roll;
        var startFov = lastActionKeyframe.Fov;

        // End state: original camera state
        var endOffset = context.OriginalState.Offset;
        var endYaw = context.OriginalState.Yaw;
        var endPitch = context.OriginalState.Pitch;
        var endRoll = context.OriginalState.Roll;
        var endFov = context.OriginalState.Fov;

        for (int i = 0; i < keyframeCount; i++)
        {
            float linearProgress = (float)i / (keyframeCount - 1);
            float easedProgress = EasingFunctions.ApplyEasing(linearProgress, context.EndLerpEasing);

            var offset = Lerp(startOffset, endOffset, easedProgress);
            var yaw = Lerp(startYaw, endYaw, easedProgress);
            var pitch = Lerp(startPitch, endPitch, easedProgress);
            var roll = Lerp(startRoll, endRoll, easedProgress);
            var fov = Lerp(startFov, endFov, easedProgress);

            float timestamp = startTime + (linearProgress * context.EndLerpTime);
            string? debugLabel = i == 0 ? "End Lerp Begin" :
                                 i == keyframeCount - 1 ? "End Lerp End / Restore Complete" : null;

            keyframes.Add(new CameraKeyframe(timestamp, offset, yaw, pitch, roll, fov, debugLabel));
        }

        return keyframes;
    }

    /// <summary>
    /// Linear interpolation for double3.
    /// </summary>
    private static double3 Lerp(double3 start, double3 end, float t)
    {
        return start + (end - start) * t;
    }

    /// <summary>
    /// Linear interpolation for float.
    /// </summary>
    private static float Lerp(float start, float end, float t)
    {
        return start + (end - start) * t;
    }

    /// <summary>
    /// Converts a quaternion to Yaw/Pitch/Roll angles in ECL coordinate system.
    /// </summary>
    private static (float yaw, float pitch, float roll) QuaternionToYPR(doubleQuat q)
    {
        var qw = q.W;
        var qx = q.X;
        var qy = q.Y;
        var qz = q.Z;

        double r00 = 1.0 - 2.0 * (qy * qy + qz * qz);
        double r01 = 2.0 * (qx * qy - qw * qz);
        double r11 = 1.0 - 2.0 * (qx * qx + qz * qz);
        double r20 = 2.0 * (qx * qz - qw * qy);
        double r21 = 2.0 * (qy * qz + qw * qx);
        double r22 = 1.0 - 2.0 * (qx * qx + qy * qy);

        var pitch = Math.Asin(Math.Clamp(r21, -1.0, 1.0));
        var yaw = Math.Atan2(-r01, r11);
        var roll = Math.Atan2(-r20, r22);

        return (
            (float)(yaw * 180.0 / Math.PI),
            (float)(pitch * 180.0 / Math.PI),
            (float)(roll * 180.0 / Math.PI)
        );
    }
}
